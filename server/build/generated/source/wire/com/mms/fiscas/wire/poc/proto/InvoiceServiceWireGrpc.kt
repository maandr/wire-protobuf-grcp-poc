// Code generated by Wire protocol buffer compiler, do not edit.
// Source: com.mms.fiscas.wire.poc.proto.InvoiceService in invoice.proto
package com.mms.fiscas.wire.poc.proto

import io.grpc.BindableService
import io.grpc.CallOptions
import io.grpc.Channel
import io.grpc.MethodDescriptor
import io.grpc.ServerServiceDefinition
import io.grpc.ServiceDescriptor
import io.grpc.ServiceDescriptor.newBuilder
import io.grpc.stub.AbstractStub
import io.grpc.stub.ClientCalls
import io.grpc.stub.ClientCalls.blockingUnaryCall
import io.grpc.stub.ServerCalls.asyncUnaryCall
import io.grpc.stub.StreamObserver
import java.io.InputStream
import java.lang.UnsupportedOperationException
import java.util.concurrent.ExecutorService
import kotlin.String
import kotlin.Unit
import kotlin.jvm.Volatile

public object InvoiceServiceWireGrpc {
  public val SERVICE_NAME: String = "com.mms.fiscas.wire.poc.proto.InvoiceService"

  @Volatile
  private var serviceDescriptor: ServiceDescriptor? = null

  @Volatile
  private var getGetInvoiceMethod: MethodDescriptor<InvoiceRequest, InvoiceResponse>? = null

  public fun getServiceDescriptor(): ServiceDescriptor? {
    var result = serviceDescriptor
    if (result == null) {
      synchronized(InvoiceServiceWireGrpc::class) {
        result = serviceDescriptor
        if (result == null) {
          result = newBuilder(SERVICE_NAME)
          .addMethod(getGetInvoiceMethod())
          .build()
          serviceDescriptor = result
        }
      }
    }
    return result
  }

  public fun getGetInvoiceMethod(): MethodDescriptor<InvoiceRequest, InvoiceResponse> {
    var result: MethodDescriptor<InvoiceRequest, InvoiceResponse>? = getGetInvoiceMethod
    if (result == null) {
      synchronized(InvoiceServiceWireGrpc::class) {
        result = getGetInvoiceMethod
        if (result == null) {
          getGetInvoiceMethod = MethodDescriptor.newBuilder<InvoiceRequest, InvoiceResponse>()
            .setType(MethodDescriptor.MethodType.UNARY)
            .setFullMethodName(
              MethodDescriptor.generateFullMethodName(
                "com.mms.fiscas.wire.poc.proto.InvoiceService", "GetInvoice"
              )
            )
            .setSampledToLocalTracing(true)
            .setRequestMarshaller(InvoiceServiceImplBase.InvoiceRequestMarshaller())
            .setResponseMarshaller(InvoiceServiceImplBase.InvoiceResponseMarshaller())
            .build()
        }
      }
    }
    return getGetInvoiceMethod!!
  }

  public fun newStub(channel: Channel): InvoiceServiceStub = InvoiceServiceStub(channel)

  public fun newBlockingStub(channel: Channel): InvoiceServiceBlockingStub =
      InvoiceServiceBlockingStub(channel)

  public abstract class InvoiceServiceImplBase : BindableService {
    public open fun GetInvoice(request: InvoiceRequest, response: StreamObserver<InvoiceResponse>) =
        throw UnsupportedOperationException()

    public override fun bindService(): ServerServiceDefinition =
        ServerServiceDefinition.builder(getServiceDescriptor()).addMethod(
              getGetInvoiceMethod(),
              asyncUnaryCall(this@InvoiceServiceImplBase::GetInvoice)
            ).build()

    public class InvoiceRequestMarshaller : MethodDescriptor.Marshaller<InvoiceRequest> {
      public override fun stream(`value`: InvoiceRequest): InputStream =
          InvoiceRequest.ADAPTER.encode(value).inputStream()

      public override fun parse(stream: InputStream): InvoiceRequest =
          InvoiceRequest.ADAPTER.decode(stream)
    }

    public class InvoiceResponseMarshaller : MethodDescriptor.Marshaller<InvoiceResponse> {
      public override fun stream(`value`: InvoiceResponse): InputStream =
          InvoiceResponse.ADAPTER.encode(value).inputStream()

      public override fun parse(stream: InputStream): InvoiceResponse =
          InvoiceResponse.ADAPTER.decode(stream)
    }
  }

  public class InvoiceServiceImplLegacyAdapter(
    private val streamExecutor: ExecutorService,
    private val GetInvoice: () -> InvoiceServiceGetInvoiceBlockingServer
  ) : InvoiceServiceImplBase() {
    public override fun GetInvoice(request: InvoiceRequest,
        response: StreamObserver<InvoiceResponse>): Unit {
      response.onNext(GetInvoice().GetInvoice(request))
      response.onCompleted()
    }
  }

  public class InvoiceServiceStub : AbstractStub<InvoiceServiceStub> {
    internal constructor(channel: Channel) : super(channel)

    internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions)

    public override fun build(channel: Channel, callOptions: CallOptions) =
        InvoiceServiceStub(channel, callOptions)

    public fun GetInvoice(request: InvoiceRequest, response: StreamObserver<InvoiceResponse>):
        Unit {
      ClientCalls.asyncUnaryCall(channel.newCall(getGetInvoiceMethod(), callOptions), request,
          response)
    }
  }

  public class InvoiceServiceBlockingStub : AbstractStub<InvoiceServiceStub> {
    internal constructor(channel: Channel) : super(channel)

    internal constructor(channel: Channel, callOptions: CallOptions) : super(channel, callOptions)

    public override fun build(channel: Channel, callOptions: CallOptions) =
        InvoiceServiceStub(channel, callOptions)

    public fun GetInvoice(request: InvoiceRequest): InvoiceResponse = blockingUnaryCall(channel,
        getGetInvoiceMethod(), callOptions, request)
  }
}
